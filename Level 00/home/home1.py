# მოცემული 3 მთელი a, b, c ̸= 0 რიცხვებისთვის მოძებნეთ a და
# b რიცხვებს შორის მოხვედრილი c რიცხვის ჯერადი რიცხვების
# რაოდენობა ყველა შესაძლო ვარიანტისთვის. თუ რომელიმე
# a, b-დან ჯერადია c-ს, მაშინ ჩათვალეთ შესაბამისი საზღვარი.
# მოიფიქრეთ ამოცანის ამოხსნის ალგორითმი, დაწერეთ და გაუშვით პროგრამა ციკლის და რეკურსიის (აგრეთვე range) კონსტრუქციის გამოყენების გარეშე


def count_multiples(a, b, c):
    if c == 0:
        return "C can not be 0" 
    
    if a > b: # ვაკეთებ ისე, რომ a ყოველთვის ნაკლები იყოს b-ზე
        a, b = b, a 
    
    if a % c == 0: # თუ a ჯერადია c-ს, მაშინ დავიწყოთ საწყისი რიცხვი a-დან
        start = a 
    else:
        x = a % c # ხოლო, თუ ესე არაა, მაშინ ვამოწმებთ თუ რამდენია ნაშთი და ვინახავთ ცვლადში x
        start = a + (c - x) # ეხლა უნდა გავხადოთ a, c-ს გამყოფი

    if b % c == 0: # ვაკეთებთ იგივეს b-სთვის (ბოლო რიცხვი b-ზე)
        end = b 
    else:
        end = b - (b % c) #თუ არა, მაშინ უკვე ვაკლებთ b-ს იმდენს, რომ მივიღოთ c-ს ჯერადი რიცხვი
        
    if start > end: # ელხა კი თუ საწყისი რიცხვი დიდია ბოლოზე, მაშინ გამოიტანს 0-ს
        return 0

    count = (end - start) // c + 1 # გამოითვლის რამდენი ჯერ გამოიტანს c-ს ჯერადს საწყისი და ბოლო რიცხვების შორის
    return count

# შემოწმება
a = 1
b = 2
c = 11
# პასუხი:
print(f"from {a} to {b}, {c}'s multiplies (including {c}) are: {count_multiples(a, b, c)}")